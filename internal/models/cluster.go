// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Cluster cluster
//
// swagger:model Cluster
type Cluster struct {

	// cpu model
	// Required: true
	CPUModel *string `json:"cpuModel"`

	// create time
	// Required: true
	// Format: date-time
	CreateTime *strfmt.DateTime `json:"createTime"`

	// gpu free
	// Required: true
	GpuFree *int32 `json:"gpuFree"`

	// gpu model
	// Required: true
	GpuModel *string `json:"gpuModel"`

	// gpu model Id
	// Required: true
	GpuModelID *string `json:"gpuModelId"`

	// gpu model pci types
	// Required: true
	GpuModelPciTypes []string `json:"gpuModelPciTypes"`

	// gpu price hr
	// Required: true
	GpuPriceHr *Decimal `json:"gpuPriceHr"`

	// gpu used
	// Required: true
	GpuUsed *int32 `json:"gpuUsed"`

	// host count
	// Required: true
	HostCount *int32 `json:"hostCount"`

	// host problem count
	// Required: true
	HostProblemCount *int32 `json:"hostProblemCount"`

	// machine type
	// Required: true
	MachineType *string `json:"machineType"`

	// max vcpu per gpu
	// Required: true
	MaxVcpuPerGpu *float64 `json:"maxVcpuPerGpu"`

	// max vcpu per memory gib
	// Required: true
	MaxVcpuPerMemoryGib *float64 `json:"maxVcpuPerMemoryGib"`

	// memory gib free
	// Required: true
	MemoryGibFree *int32 `json:"memoryGibFree"`

	// memory gib price hr
	// Required: true
	MemoryGibPriceHr *Decimal `json:"memoryGibPriceHr"`

	// memory gib used
	// Required: true
	MemoryGibUsed *int32 `json:"memoryGibUsed"`

	// min vcpu per gpu
	// Required: true
	MinVcpuPerGpu *float64 `json:"minVcpuPerGpu"`

	// min vcpu per memory gib
	// Required: true
	MinVcpuPerMemoryGib *float64 `json:"minVcpuPerMemoryGib"`

	// update time
	// Required: true
	// Format: date-time
	UpdateTime *strfmt.DateTime `json:"updateTime"`

	// vcpu free
	// Required: true
	VcpuFree *int32 `json:"vcpuFree"`

	// vcpu per Cpu thread
	// Required: true
	VcpuPerCPUThread *int32 `json:"vcpuPerCpuThread"`

	// vcpu price hr
	// Required: true
	VcpuPriceHr *Decimal `json:"vcpuPriceHr"`

	// vcpu used
	// Required: true
	VcpuUsed *int32 `json:"vcpuUsed"`

	// vm count
	// Required: true
	VMCount *int32 `json:"vmCount"`
}

// Validate validates this cluster
func (m *Cluster) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCPUModel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCreateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpuFree(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpuModel(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpuModelID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpuModelPciTypes(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpuPriceHr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateGpuUsed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateHostProblemCount(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMachineType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxVcpuPerGpu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMaxVcpuPerMemoryGib(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemoryGibFree(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemoryGibPriceHr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMemoryGibUsed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinVcpuPerGpu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMinVcpuPerMemoryGib(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUpdateTime(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcpuFree(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcpuPerCPUThread(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcpuPriceHr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVcpuUsed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVMCount(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) validateCPUModel(formats strfmt.Registry) error {

	if err := validate.Required("cpuModel", "body", m.CPUModel); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateCreateTime(formats strfmt.Registry) error {

	if err := validate.Required("createTime", "body", m.CreateTime); err != nil {
		return err
	}

	if err := validate.FormatOf("createTime", "body", "date-time", m.CreateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateGpuFree(formats strfmt.Registry) error {

	if err := validate.Required("gpuFree", "body", m.GpuFree); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateGpuModel(formats strfmt.Registry) error {

	if err := validate.Required("gpuModel", "body", m.GpuModel); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateGpuModelID(formats strfmt.Registry) error {

	if err := validate.Required("gpuModelId", "body", m.GpuModelID); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateGpuModelPciTypes(formats strfmt.Registry) error {

	if err := validate.Required("gpuModelPciTypes", "body", m.GpuModelPciTypes); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateGpuPriceHr(formats strfmt.Registry) error {

	if err := validate.Required("gpuPriceHr", "body", m.GpuPriceHr); err != nil {
		return err
	}

	if m.GpuPriceHr != nil {
		if err := m.GpuPriceHr.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gpuPriceHr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gpuPriceHr")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateGpuUsed(formats strfmt.Registry) error {

	if err := validate.Required("gpuUsed", "body", m.GpuUsed); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateHostCount(formats strfmt.Registry) error {

	if err := validate.Required("hostCount", "body", m.HostCount); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateHostProblemCount(formats strfmt.Registry) error {

	if err := validate.Required("hostProblemCount", "body", m.HostProblemCount); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateMachineType(formats strfmt.Registry) error {

	if err := validate.Required("machineType", "body", m.MachineType); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateMaxVcpuPerGpu(formats strfmt.Registry) error {

	if err := validate.Required("maxVcpuPerGpu", "body", m.MaxVcpuPerGpu); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateMaxVcpuPerMemoryGib(formats strfmt.Registry) error {

	if err := validate.Required("maxVcpuPerMemoryGib", "body", m.MaxVcpuPerMemoryGib); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateMemoryGibFree(formats strfmt.Registry) error {

	if err := validate.Required("memoryGibFree", "body", m.MemoryGibFree); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateMemoryGibPriceHr(formats strfmt.Registry) error {

	if err := validate.Required("memoryGibPriceHr", "body", m.MemoryGibPriceHr); err != nil {
		return err
	}

	if m.MemoryGibPriceHr != nil {
		if err := m.MemoryGibPriceHr.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("memoryGibPriceHr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("memoryGibPriceHr")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateMemoryGibUsed(formats strfmt.Registry) error {

	if err := validate.Required("memoryGibUsed", "body", m.MemoryGibUsed); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateMinVcpuPerGpu(formats strfmt.Registry) error {

	if err := validate.Required("minVcpuPerGpu", "body", m.MinVcpuPerGpu); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateMinVcpuPerMemoryGib(formats strfmt.Registry) error {

	if err := validate.Required("minVcpuPerMemoryGib", "body", m.MinVcpuPerMemoryGib); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateUpdateTime(formats strfmt.Registry) error {

	if err := validate.Required("updateTime", "body", m.UpdateTime); err != nil {
		return err
	}

	if err := validate.FormatOf("updateTime", "body", "date-time", m.UpdateTime.String(), formats); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateVcpuFree(formats strfmt.Registry) error {

	if err := validate.Required("vcpuFree", "body", m.VcpuFree); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateVcpuPerCPUThread(formats strfmt.Registry) error {

	if err := validate.Required("vcpuPerCpuThread", "body", m.VcpuPerCPUThread); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateVcpuPriceHr(formats strfmt.Registry) error {

	if err := validate.Required("vcpuPriceHr", "body", m.VcpuPriceHr); err != nil {
		return err
	}

	if m.VcpuPriceHr != nil {
		if err := m.VcpuPriceHr.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vcpuPriceHr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vcpuPriceHr")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) validateVcpuUsed(formats strfmt.Registry) error {

	if err := validate.Required("vcpuUsed", "body", m.VcpuUsed); err != nil {
		return err
	}

	return nil
}

func (m *Cluster) validateVMCount(formats strfmt.Registry) error {

	if err := validate.Required("vmCount", "body", m.VMCount); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this cluster based on the context it is used
func (m *Cluster) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateGpuPriceHr(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateMemoryGibPriceHr(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVcpuPriceHr(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Cluster) contextValidateGpuPriceHr(ctx context.Context, formats strfmt.Registry) error {

	if m.GpuPriceHr != nil {

		if err := m.GpuPriceHr.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("gpuPriceHr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("gpuPriceHr")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateMemoryGibPriceHr(ctx context.Context, formats strfmt.Registry) error {

	if m.MemoryGibPriceHr != nil {

		if err := m.MemoryGibPriceHr.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("memoryGibPriceHr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("memoryGibPriceHr")
			}
			return err
		}
	}

	return nil
}

func (m *Cluster) contextValidateVcpuPriceHr(ctx context.Context, formats strfmt.Registry) error {

	if m.VcpuPriceHr != nil {

		if err := m.VcpuPriceHr.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vcpuPriceHr")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vcpuPriceHr")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Cluster) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Cluster) UnmarshalBinary(b []byte) error {
	var res Cluster
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
